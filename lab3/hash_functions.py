import hashlib

sTable = [
	0xa3, 0xd7, 0x09, 0x83, 0xf8, 0x48, 0xf6, 0xf4, 0xb3, 0x21, 0x15, 0x78, 0x99, 0xb1, 0xaf, 0xf9,
	0xe7, 0x2d, 0x4d, 0x8a, 0xce, 0x4c, 0xca, 0x2e, 0x52, 0x95, 0xd9, 0x1e, 0x4e, 0x38, 0x44, 0x28,
	0x0a, 0xdf, 0x02, 0xa0, 0x17, 0xf1, 0x60, 0x68, 0x12, 0xb7, 0x7a, 0xc3, 0xe9, 0xfa, 0x3d, 0x53,
	0x96, 0x84, 0x6b, 0xba, 0xf2, 0x63, 0x9a, 0x19, 0x7c, 0xae, 0xe5, 0xf5, 0xf7, 0x16, 0x6a, 0xa2,
	0x39, 0xb6, 0x7b, 0x0f, 0xc1, 0x93, 0x81, 0x1b, 0xee, 0xb4, 0x1a, 0xea, 0xd0, 0x91, 0x2f, 0xb8,
	0x55, 0xb9, 0xda, 0x85, 0x3f, 0x41, 0xbf, 0xe0, 0x5a, 0x58, 0x80, 0x5f, 0x66, 0x0b, 0xd8, 0x90,
	0x35, 0xd5, 0xc0, 0xa7, 0x33, 0x06, 0x65, 0x69, 0x45, 0x00, 0x94, 0x56, 0x6d, 0x98, 0x9b, 0x76,
	0x97, 0xfc, 0xb2, 0xc2, 0xb0, 0xfe, 0xdb, 0x20, 0xe1, 0xeb, 0xd6, 0xe4, 0xd4, 0x47, 0x4a, 0x1d,
	0x42, 0xed, 0x9e, 0x6e, 0x49, 0x3c, 0xcd, 0x43, 0x27, 0xd2, 0x07, 0xd4, 0xde, 0xc7, 0x67, 0x18,
	0x89, 0xcb, 0x30, 0x1f, 0x8d, 0xc6, 0x8f, 0xaa, 0xc8, 0x74, 0xdc, 0xc9, 0x5d, 0x5c, 0x31, 0xa4,
	0x70, 0x88, 0x61, 0x2c, 0x9f, 0x0d, 0x2b, 0x87, 0x50, 0x82, 0x54, 0x64, 0x26, 0x7d, 0x03, 0x40,
	0x34, 0x4b, 0x1c, 0x73, 0xd1, 0xc4, 0xfd, 0x3b, 0xcc, 0xfb, 0x7f, 0xab, 0xe6, 0x3e, 0x5b, 0xa5,
	0xad, 0x04, 0x23, 0x9c, 0x14, 0x51, 0x22, 0xf0, 0x29, 0x79, 0x71, 0x7e, 0xff, 0x8c, 0x0e, 0xe2,
	0x0c, 0xef, 0xbc, 0x72, 0x75, 0x6f, 0x37, 0xa1, 0xec, 0xd3, 0x8e, 0x62, 0x8b, 0x86, 0x10, 0xe8,
	0x08, 0x77, 0x11, 0xbe, 0x92, 0x4f, 0x24, 0xc5, 0x32, 0x36, 0x9d, 0xcf, 0xf3, 0xa6, 0xbb, 0xac,
	0x5e, 0x6c, 0xa9, 0x13, 0x57, 0x25, 0xb5, 0xe3, 0xbd, 0xa8, 0x3a, 0x01, 0x05, 0x59, 0x2a, 0x46
]

class HashFunctions:
	@staticmethod
	def ma_prime_hash(data: bytes) -> int:
		PRIME_MULT = 0x1FAF
		START_PRIME = 0x3A8F05C5
		hval = START_PRIME

		for i, byte in enumerate(data):
			index = (byte + i) & 0xFF
			hval ^= sTable[index]
			hval = (hval * PRIME_MULT) & 0xFFFFFFFF

		return hval

	@staticmethod
	def gost_341194_hash(data: bytes) -> bytes:
		BLOCK_SIZE = 32
		h = bytearray([0] * BLOCK_SIZE)
		N = bytearray([0] * BLOCK_SIZE)
		Sigma = bytearray([0] * BLOCK_SIZE)
		original_len = len(data)
		data = bytearray(data)
		data.append(0x01)

		while len(data) % BLOCK_SIZE != 0:
			data.append(0x00)
		
		for i in range(0, len(data), BLOCK_SIZE):
			block = data[i:i + BLOCK_SIZE]
			h = HashFunctions._gost_compression_function(h, block, N, Sigma)
			
			N = HashFunctions._add_mod_2_512(N, [BLOCK_SIZE * 8] * BLOCK_SIZE)
			Sigma = HashFunctions._add_mod_2_512(Sigma, [int(b) for b in block])
		
		return bytes(h)
	
	@staticmethod
	def _gost_compression_function(
		h: bytearray,
		m: bytes,
		N: bytearray,
		Sigma: bytearray
	) -> bytearray:
		keys = HashFunctions._gost_key_schedule(h, N)
		result = bytearray(32)

		for i in range(4):
			block_start = i * 8
			block_end = block_start + 8
			data_block = m[block_start:block_end]
			h_block = h[block_start:block_end]

			transformed = HashFunctions._gost_transform_block(data_block, keys)

			for j in range(8):
				result[block_start + j] = transformed[j] ^ h_block[j]
		
		return result
		
	@staticmethod
	def _gost_key_schedule(K: bytearray, N: bytearray) -> list:
		keys = []

		k_blocks = [K[i:i + 8] for i in range(0, 32, 8)]
		n_blocks = [N[i:i + 8] for i in range(0, 32, 8)]

		for round_num in range(32):
			if round_num < 8:
				key_source = k_blocks
				key_index = round_num % 4
			else:
				key_source = n_blocks
				key_index = (round_num // 4) % 4
			
			key = bytearray(key_source[key_index])
			key[0] ^= round_num
			key[7] ^= 0xFF - round_num

			keys.append(bytes(key))
		
		return keys
	
	@staticmethod
	def _gost_transform_block(block: bytes, keys: list) -> bytes:
		state = bytearray(block)

		for round_num in range(32):
			key = keys[round_num]
			
			for j in range(8):
				state[j] ^= key[j]
			
			for j in range(8):
				state[j] = HashFunctions._gost_sbox(state[j])
			
			state = HashFunctions._gost_rotate_left(state, 11)
		
		return bytes(state)

	@staticmethod
	def _gost_sbox(value: int) -> int:
		return (value * 17 + 173) & 0xFF

	@staticmethod
	def _gost_rotate_left(data: bytearray, bits: int) -> bytearray:
		result = bytearray(len(data))
		byte_shift = bits // 8
		bit_shft = bits % 8

		for i in range(len(data)):
			byte1 = data[(i - byte_shift) % len(data)]
			byte2 = data[(i - byte_shift - 1) % len(data)]
			result[i] = ((byte1 << bit_shft) | (byte2 >> (8 - bit_shft))) & 0xFF
		
		return result

	
	@staticmethod
	def _add_mod_2_512(a: bytearray, b: list) -> bytearray:
		result = bytearray(32)
		carry = 0
		
		for i in range(31, -1, -1):
			total = a[i] + b[i] + carry
			result[i] = total & 0xFF
			carry = total >> 8
		
		return result
	
	@staticmethod
	def ready_hash(data: bytes, algorithm: str = 'sha256') -> bytes:
		if algorithm == 'md5':
			return hashlib.md5(data).digest()
		elif algorithm == 'sha1':
			return hashlib.sha1(data).digest()
		elif algorithm == 'sha256':
			return hashlib.sha256(data).digest()
		else:
			raise ValueError(f"Unsupported algorithm: {algorithm}")
		